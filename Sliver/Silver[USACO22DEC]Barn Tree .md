# [USACO22DEC] Barn Tree
原题link: https://usaco.org/index.php?page=viewproblem2&cpid=1254

洛谷链接:https://www.luogu.com.cn/problem/P8900

***\*注意：本题的时间限制为 4 秒，通常限制的两倍。内存限制同样是通常限制的两倍。\****

Farmer John 的农场有 NN 个牛棚（2≤N≤2⋅1052≤N≤2⋅105），编号为 1…N1…N。有 N−1N−1 条道路，每条道路连接两个牛棚，并且从任一牛棚均可通过一些道路到达任一其他牛棚。目前，第 jj 个牛棚中有 hjhj 个干草捆（1≤hj≤1091≤hj≤109）。

为使他的奶牛们满意，Farmer John 想移动这些干草，使得每个牛棚都有相同数量的干草捆。他可以选择任何一对由一条道路连接的牛棚，并命令他的农场工人将不超过第一个牛棚中干草捆数量的任意正整数个干草捆从第一个牛棚移动到第二个牛棚。

请求出一个 Farmer John 可以发出的命令序列，以尽可能少的命令数完成这一任务。输入保证存在符合要求的命令序列。

#### 输入格式（从终端 / 标准输入读入）：

输入的第一行包含整数 NN。

第二行包含空格分隔的整数 hjhj，其中 j=1…Nj=1…N。

最后 N−1N−1 行每行包含两个空格分隔的牛棚编号 ui viui vi，表示有一条双向道路连接 uiui 和 vivi。

#### 输出格式（输出至终端 / 标准输出）：

输出命令的最小数量，然后输出该数量的命令序列，每行输出一条命令。

每条命令的格式应为三个空格分隔的正整数：出发牛棚，目标牛棚，以及从出发牛棚移动到目标牛棚的干草捆数量。

如果有多组解，输出任意一组。

#### 输入样例：

```
4
2 1 4 5
1 2
2 3
2 4
```

#### 输出样例：

```
3
3 2 1
4 2 2
2 1 1
```

在这个例子中，共有十二个干草捆和四个牛棚，这意味着每个牛棚最后必须有三个干草捆。输出样例中的命令顺序可以用以下的自然语言表述：



1. 从牛棚 33 到牛棚 22，移动 11 个干草捆。
2. 从牛棚 44 到牛棚 22，移动 22 个干草捆。
3. 从牛棚 22 到牛棚 11，移动 11 个干草捆。

#### 测试点性质：

- 测试点 2-8 满足 N≤5000N≤5000。
- 测试点 7-10 满足 vi=ui+1vi=ui+1。
- 测试点 11-16 没有额外限制。

在这个问题中，我们使用了图论中的以下知识：

1. **树的性质**：给定的道路形成了树结构，树是一个无环连通图，这意味着从任意节点出发，都可以到达其他所有节点。
2. **深度优先搜索（DFS）**：DFS是一种用于遍历或搜索树或图的算法。在这个问题中，我们使用DFS来计算每个节点的子树干草捆总数，并调整干草捆的数量以实现平衡。
3. **图的表示**：图可以用多种方式表示，如邻接矩阵、邻接表等。在这个代码中，我们使用了邻接表来表示图。

以下是创建和使用图的过程：

### 如何创建一张图

1. **初始化图的节点和边**：在 `Graph` 类的构造函数中，我们初始化了图的节点数 `n` 和邻接表 `adj`，以及每个节点的干草捆数量 `val`。

```
class Graph:
    def __init__(self, n):
        self.n = n
        self.adj = [[] for _ in range(n + 1)]  # 初始化邻接表
        self.val = [0] * (n + 1)  # 初始化每个节点的干草捆数量
        # ... 其他初始化
```

1. **添加边**：在 `add_edge` 方法中，我们通过添加边来构建图。对于每条边 `(u, v)`，我们在邻接表中添加对方节点。

```
def add_edge(self, u, v):
    self.adj[u].append(v)
    self.adj[v].append(u)
```

### 如何使用图的知识

1. **计算每个节点的子树干草捆总数**：在 `dfs1` 方法中，我们使用DFS遍历图，计算每个节点的子树干草捆总数。如果子节点的干草捆数量大于0，表示需要将干草捆移动到父节点。

```
def dfs1(self, u, fa):
    for v in self.adj[u]:
        if v == fa:
            continue
        self.dfs1(v, u)
        if self.val[v] > 0:
            # 记录移动命令
            self.ansu.append(v)
            self.ansv.append(u)
            self.answ.append(self.val[v])
            self.ansc += 1
        self.val[u] += self.val[v]
```

1. **调整干草捆数量以实现平衡**：在 `dfs2` 方法中，我们再次使用DFS遍历图，这次是为了调整干草捆的数量，使得每个节点的干草捆数量为0。如果子节点的干草捆数量小于0，表示需要从父节点向子节点移动干草捆。

```
def dfs2(self, u, fa):
    for v in self.adj[u]:
        if v == fa:
            continue
        if self.val[v] < 0:
            # 记录移动命令
            self.ansu.append(u)
            self.ansv.append(v)
            self.answ.append(-self.val[v])
            self.ansc += 1
        self.dfs2(v, u)
```

通过这些步骤，我们能够计算出需要移动干草捆的最小命令数，并输出具体的移动命令。这个过程利用了图论中关于树和DFS的知识来解决问题。

在这段代码中，`dfs1` 和 `dfs2` 有不同的用途，具体如下：

### `dfs1` 的作用：

1. **累加子树值**：
   - 它从根节点开始，遍历整棵树。
   - 对于每个节点 `u`，累加其所有子节点 `v` 的值 `val[v]` 到 `val[u]`。这使得 `val[u]` 表示以 `u` 为根的子树的总值。

2. **记录正值的边**：
   - 如果某个子节点 `v` 的值 `val[v]` 大于 0，则记录从 `v` 到 `u` 的边及其值。这表示需要从 `v` 向 `u` 转移的值。

### `dfs2` 的作用：

1. **处理负值的边**：
   - 再次从根节点开始遍历整个树。
   - 如果某个子节点 `v` 的值 `val[v]` 小于 0，则记录从 `u` 到 `v` 的边及其负值。这表示需要从 `u` 向 `v` 转移的值。

### 总结：

- **`dfs1`** 用于从下到上累加子树的值，并记录需要向上转移的值。
- **`dfs2`** 用于从上到下处理需要向下转移的值。

这两个遍历的组合可以有效地平衡树中节点的值，以满足某种特定的条件或需求。
